[{"authors":null,"categories":null,"date":1615939200,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"term","lang":"zh","lastmod":1615939200,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/algorithm/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/algorithm/","section":"tags","summary":"","tags":null,"title":"Algorithm","type":"tags","url":"/ianlife/tags/algorithm/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1615939200,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1615939200,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/blog/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/blog/","section":"blog","summary":"","tags":null,"title":"Blog","type":"blog","url":"/ianlife/blog/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1615939200,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1615939200,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/categories/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/categories/","section":"categories","summary":"","tags":null,"title":"Categories","type":"categories","url":"/ianlife/categories/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1615939200,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"term","lang":"zh","lastmod":1615939200,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/series/it-%E4%BA%BA%E5%BF%85%E4%BF%AE-%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/series/it-%E4%BA%BA%E5%BF%85%E4%BF%AE-%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/","section":"series","summary":"","tags":null,"title":"IT 人必修 - 資料結構與演算法","type":"series","url":"/ianlife/series/it-%E4%BA%BA%E5%BF%85%E4%BF%AE-%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1615939200,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"home","lang":"zh","lastmod":1615939200,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/","section":"","summary":"","tags":null,"title":"Life Story","type":"page","url":"/ianlife/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1615939200,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1615939200,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/series/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/series/","section":"series","summary":"","tags":null,"title":"Series","type":"series","url":"/ianlife/series/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1615939200,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1615939200,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/","section":"tags","summary":"","tags":null,"title":"Tags","type":"tags","url":"/ianlife/tags/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1615939200,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"term","lang":"zh","lastmod":1615939200,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/categories/tech/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/categories/tech/","section":"categories","summary":"","tags":null,"title":"TECH","type":"categories","url":"/ianlife/categories/tech/","weight":0,"wordcount":0},{"authors":null,"categories":["TECH"],"date":1615939200,"description":"快速排序使用分治法（Divide and conquer）策略，藉由一個基準值來把一個序列（list）分為較小（左）和較大（右）的 2 個子序列，然後遞迴地排序兩個子序列。","dir":"blog/technology/data_structures_and_algorithms/","expirydate":-62135596800,"fuzzywordcount":800,"keywords":["演算法","Algorithm","Quick Sort","快速排序法"],"kind":"page","lang":"zh","lastmod":1615939200,"objectID":"42206d43bf586b7e0f16a050be283ecb","permalink":"https://ianjustin39.github.io/ianlife/algorithms/quick-sort/","publishdate":"2021-03-17T00:00:00Z","readingtime":4,"relpermalink":"/ianlife/algorithms/quick-sort/","section":"blog","summary":"","tags":["Algorithm"],"title":"快速排序 - Quick Sort","type":"Data Structures and Algorithms","url":"algorithms/quick-sort","weight":0,"wordcount":717},{"authors":null,"categories":["TECH"],"date":1615852800,"description":"合併排序法屬於分治法（Divide and Conquer）演算法，先把大問題拆解成小問題，解決小問題後再將小問題合併，進而解決大問題。","dir":"blog/technology/data_structures_and_algorithms/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":["演算法","Algorithm","Data Structures","Merge Sort","合併排序"],"kind":"page","lang":"zh","lastmod":1615852800,"objectID":"4f0d7f7d079e0a0843d53a726c3ad318","permalink":"https://ianjustin39.github.io/ianlife/algorithms/merge-sort/","publishdate":"2021-03-16T00:00:00Z","readingtime":2,"relpermalink":"/ianlife/algorithms/merge-sort/","section":"blog","summary":"","tags":["Algorithm"],"title":"合併排序 - Merge Sort","type":"Data Structures and Algorithms","url":"algorithms/merge-sort","weight":0,"wordcount":260},{"authors":null,"categories":["TECH"],"date":1615766400,"description":"泡沫排序是一種穩定排序演算法，不斷重複比較兩個元素，如果要最小的開頭，若前一個元素小於現在這個元素，則兩個元素位置互換，反之亦然，直到所有元素都是由小到大排序才結束。而也因為這種『小元素經由交換慢慢浮至集合頂端』，故稱作泡沫排序","dir":"blog/technology/data_structures_and_algorithms/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":["演算法","Algorithm","Data Structures","Bubble Sort","泡沫排序"],"kind":"page","lang":"zh","lastmod":1615766400,"objectID":"3965d9eadb869d54154c96cad143d464","permalink":"https://ianjustin39.github.io/ianlife/algorithms/bubble-sort/","publishdate":"2021-03-15T00:00:00Z","readingtime":1,"relpermalink":"/ianlife/algorithms/bubble-sort/","section":"blog","summary":"","tags":["Algorithm"],"title":"泡沫排序 - Bubble Sort","type":"Data Structures and Algorithms","url":"algorithms/bubble-sort","weight":0,"wordcount":210},{"authors":null,"categories":null,"date":1615680000,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"term","lang":"zh","lastmod":1615680000,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/categories/life/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/categories/life/","section":"categories","summary":"","tags":null,"title":"LIFE","type":"categories","url":"/ianlife/categories/life/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1615680000,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"term","lang":"zh","lastmod":1615680000,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/series/%E7%9C%8B%E9%9B%BB%E5%BD%B1%E7%9A%84%E7%9C%81%E6%80%9D/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/series/%E7%9C%8B%E9%9B%BB%E5%BD%B1%E7%9A%84%E7%9C%81%E6%80%9D/","section":"series","summary":"","tags":null,"title":"看電影的省思","type":"series","url":"/ianlife/series/%E7%9C%8B%E9%9B%BB%E5%BD%B1%E7%9A%84%E7%9C%81%E6%80%9D/","weight":0,"wordcount":0},{"authors":null,"categories":["LIFE"],"date":1615680000,"description":"不管這個世界怎麼看你，你都要相信你自己。","dir":"blog/life/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":["複身犯","plurality"],"kind":"page","lang":"zh","lastmod":1615680000,"objectID":"03c5754c533bf7b3f70140010cdc8b3c","permalink":"https://ianjustin39.github.io/ianlife/movie/plurality/","publishdate":"2021-03-14T00:00:00Z","readingtime":1,"relpermalink":"/ianlife/movie/plurality/","section":"blog","summary":"上次看電影是2019年的事（沒看天能，有理由不當低能🤣），而上次看國片更不知何時了，對於國片的記憶還停留在『大尾鱸鰻』、『總鋪師』等等賀歲片，這次剛好朋友介紹而看這部電影，起初以為是類似於人格分裂的犯罪電影，想不到劇情比我想的還要豐富，有點刷新了我對於國片既定的印象。雖然有部分沒有解釋的很到位，但對於我來說，看電影就是放鬆心情，不要太過於糾結🤣🤣🤣。\n以下心得可能有點雷，還沒看過的就先跳出囉！！\n人格的撕扯，我不是我。  『攔截記憶碼』是我對於這類電影的一個印象，但這片一次注入五個人格到單一個體的精神裡，是給演員的一大考驗。個人覺得楊祐寧把這五個人都詮釋的不錯，畢竟一次演兩個人就已經不是一件簡單的事了，更何況是五個人。而在這五個人存在於意識裡的空間，是與現實相同的實驗室，表示就算你們逃出了現實的實驗室，在意識裡面還是被關起來的。如果某一個人格想要驅動 193 的身體，就需要找到一個紅門，這個紅門，象徵著 193 與女兒講的『怪角鹿』的故事，那隻鹿為了面對自己而穿過的紅門。\n張榕容飾演的科學家沈宜玲，竭盡自己的所學，為了小孩，不放棄所有可能找到他的線索，體現出一個母親，可以為自己的孩子付出一切。故事的最後，意外的反轉，193 並不是許明哲，而真的許明哲，為了奪取身體而模仿甚至策劃抹殺所有人的意識，一種『我不是我，那我是誰』的感覺。\n整部下來印象最深刻的一句話還是公車司機邱俊生的：我只是想看我阿嬤啊\n觀後的省思  世界友善對待先天有缺陷的人並不友善 想起以前學生時代，大家對於一些行為怪異或是身心有缺陷的人了，往往都給予不友善的態度甚至會霸凌他們。大家普遍認為他們是怪人，給與異樣眼光，對於這些人來說，這個世界有的甚至父母，都不會友善的對待自己。片中許明哲以及 193（意識載體）分別用不同的方法，去對待這些人。但許明哲這種極端的行為，也許演出很多人內心不敢表現出的想法，而 193 則是父母對待自己子女愛的體現。不禁讓人反思，是不是因為我們而造就了這個不友善的世界？\n被『正義』包裝的『惡』 片尾王警官說：『我們沒辦法知道怪物的腦中想什麼，或許殺了他們，反而對他們比較好。』這句話就跟許明哲對沈宜玲（張榕容）講的話一樣：『這世界對他們並不友善，所以殺了他們。對他們比較好。』。往往有些『惡意』的外層包裝了『正義』，社會大眾就會覺的是合理的事，但是否只要是『正義』就是絕對的正確呢？\n不管這個世界怎麼看你，你都要相信你自己。 193 對女兒說：『不管這個世界怎麼看你，你都要相信你自己。』\n現在的人大多數在意『別人怎麼看我』，但我們是想要活出『我夢想中的自己』，還是『別人眼中的自己』。適度的在意並把意見化為養分是必要的，但應該要過濾，不是照單全收。\n最後，你們有沒有看我阿嬤啊","tags":["電影心得"],"title":"複身犯 - 寫出你的名字，你是誰？","type":"電影心得","url":"movie/plurality","weight":0,"wordcount":24},{"authors":null,"categories":null,"date":1615680000,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"term","lang":"zh","lastmod":1615680000,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/%E9%9B%BB%E5%BD%B1%E5%BF%83%E5%BE%97/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/%E9%9B%BB%E5%BD%B1%E5%BF%83%E5%BE%97/","section":"tags","summary":"","tags":null,"title":"電影心得","type":"tags","url":"/ianlife/tags/%E9%9B%BB%E5%BD%B1%E5%BF%83%E5%BE%97/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1615593600,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"term","lang":"zh","lastmod":1615593600,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/algolia/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/algolia/","section":"tags","summary":"","tags":null,"title":"Algolia","type":"tags","url":"/ianlife/tags/algolia/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1615593600,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"term","lang":"zh","lastmod":1615593600,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/blog/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/blog/","section":"tags","summary":"","tags":null,"title":"blog","type":"tags","url":"/ianlife/tags/blog/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1615593600,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"term","lang":"zh","lastmod":1615593600,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/hugo/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/hugo/","section":"tags","summary":"","tags":null,"title":"hugo","type":"tags","url":"/ianlife/tags/hugo/","weight":0,"wordcount":0},{"authors":null,"categories":["TECH"],"date":1615593600,"description":"Algolia 是為你在APP或網站提供搜索功能的最佳方式之一，在 Hugo 中加入 Algolia，讓你更方便尋找以前的文章。","dir":"blog/technology/build_blog/","expirydate":-62135596800,"fuzzywordcount":800,"keywords":null,"kind":"page","lang":"zh","lastmod":1615593600,"objectID":"487bf2884c87079d0a7c7184147429f6","permalink":"https://ianjustin39.github.io/ianlife/build-blog/hugo-and-algolia/","publishdate":"2021-03-13T00:00:00Z","readingtime":4,"relpermalink":"/ianlife/build-blog/hugo-and-algolia/","section":"blog","summary":"隨著文章越來越多，要找到以前寫的文章就越來越麻煩，所以就一直想尋找站內搜索的功能使用。之前有試用 google 的站內搜索功能，但總覺得整體不是很好看，也就沒有繼續使用。直到最近看到 Algolia ，可建立文章的索引，將資料上傳到 Algolia，再藉由串接 API 就可以完成搜索功能。\n接下來就開始建立站內搜索功能吧。\n註冊 Algolia  第一步就是要到 Algolia 註冊帳號，登入後會要求輸入一個 index（等等要用到這個 index），然後會以這個 index 建立一個 app ，接著選擇存取的國家（我是選日本），完成之後會有這個畫面。\n然後點選左邊的 API Keys，這邊有等等設定需要使用的參數，可以先將他們記下來。\n註：Algolia 有分幾個付費等級，現在有 15 天試用期，不過因為 blog 只需要簡單的搜索文章的功能，這裡目前是使用免費版，若要更進階的功能可以自行研究看看。\nhugo 生成索引文件  1. 修改 config.toml 修改./config.toml設定好需要的參數。\n[outputs] home = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;Algolia\u0026#34;] [outputFormats.Algolia] baseName = \u0026#34;algolia\u0026#34; isPlainText = true mediaType = \u0026#34;application/json\u0026#34; notAlternative = true [params.algolia] appId = \u0026#34;剛剛看到的 ID\u0026#34; indexName = \u0026#34;一開始輸入的 index\u0026#34; searchOnlyKey = \u0026#34;剛剛看到的 Search Only Key\u0026#34; vars = [\u0026#34;title\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;date\u0026#34;, \u0026#34;publishdate\u0026#34;, \u0026#34;expirydate\u0026#34;, \u0026#34;permalink\u0026#34;] params = [\u0026#34;categories\u0026#34;, \u0026#34;tags\u0026#34;, \u0026#34;series\u0026#34;]","tags":["Blog","Hugo","Algolia"],"title":"在 Hugo Blog 中加上 Algolia 文章搜索工具","type":"Build My Blog","url":"/build-blog/hugo-and-algolia","weight":0,"wordcount":729},{"authors":null,"categories":null,"date":1615593600,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"term","lang":"zh","lastmod":1615593600,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/series/%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84-blog/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/series/%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84-blog/","section":"series","summary":"","tags":null,"title":"建立自己的 Blog","type":"series","url":"/ianlife/series/%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84-blog/","weight":0,"wordcount":0},{"authors":null,"categories":["LIFE"],"date":1615507200,"description":"寧靜的下午坐在咖啡廳、喝著咖啡、看著書，思考這『這杯咖啡的價值』是什麼。","dir":"blog/life/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":["咖啡","時間","coffee","time"],"kind":"page","lang":"zh","lastmod":1615507200,"objectID":"99c371cfb85415aee26baaaaa3512570","permalink":"https://ianjustin39.github.io/ianlife/life/a-cup-of-coffee/","publishdate":"2021-03-12T00:00:00Z","readingtime":1,"relpermalink":"/ianlife/life/a-cup-of-coffee/","section":"blog","summary":"到咖啡廳唸書？  很多人喜歡到咖啡廳看書，曾經的我覺得，為何要花錢去咖啡廳看書？自制力高一點在家看不就好了，何必要多花一筆錢？那到底有沒有必要去咖啡廳唸書？\n一杯咖啡的價值  每到週末，我就會想著：『難得的假日，休息一下再來做事好了！』，然後就晚上了。是自制力不足，還是目標不夠明確所以才導致這個結果呢？\n原子習慣一書中提到，『改變習慣的四大法則之一：讓習慣淺而易見』，反之則是讓壞習慣視而不見。那這跟在家看書有什麼關係？\n想想自己房間裡的環境，看到床就想睡一下、看到電動就想玩一下、走到客廳看到電視就想看一會兒\u0026hellip;諸如此類，當我們想要在這充滿誘惑的環境做一些不屬於這個環境的事情，想必會有一定的難度，而我們的時間往往就這樣被消磨掉了。一個週末、兩個週末\u0026hellip;這樣的時間累計起來，其實也是滿可觀的。\n而我開始對『一杯咖啡的價值』開始有了不一樣的想法。他是單純菜單上的 60/100 元的『飲料』，還是他可以想成，你用這樣的價錢，控制了你一天的『時間』？\n資產與負債  一杯咖啡，怎麼會講到資產與負債？我認為這兩件事的觀念有點相似。現在常聽到人問，『什麼是資產？你的房子是不是？你的車子是不是？』，而答案通常會是『房子那來出租，就會是資產；車子拿來載客人，也是資產。』\n那我買一杯咖啡，到底是投資還是消費？\n一杯咖啡換一天的時間  高爾基：『時間是最公平合理的，它從不多給誰一分。』  老天給我們最公平的東西就是——時間，每個人都有，無論是貧賤、富貴，每個人都是一樣的，而時間是公平的，我們每個人能擁有它，但因為使用它的方式不同，導致在『相同』的時間內，沒有相同的結果。\n而現在，我用一杯咖啡，換到一個沒有誘惑的環境、換來一天的時間，這件事讓我不再認為『到咖啡廳唸書』是個浪費錢的事情，反而覺得是非常值得的『投資』。","tags":["隨手寫"],"title":"咖啡的價值 - 是買咖啡還是買時間？","type":"隨手寫","url":"life/a-cup-of-coffee","weight":0,"wordcount":16},{"authors":null,"categories":null,"date":1615507200,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"term","lang":"zh","lastmod":1615507200,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/series/%E9%9A%A8%E6%89%8B%E5%AF%AB/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/series/%E9%9A%A8%E6%89%8B%E5%AF%AB/","section":"series","summary":"","tags":null,"title":"隨手寫","type":"series","url":"/ianlife/series/%E9%9A%A8%E6%89%8B%E5%AF%AB/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1615507200,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"term","lang":"zh","lastmod":1615507200,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/%E9%9A%A8%E6%89%8B%E5%AF%AB/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/%E9%9A%A8%E6%89%8B%E5%AF%AB/","section":"tags","summary":"","tags":null,"title":"隨手寫","type":"tags","url":"/ianlife/tags/%E9%9A%A8%E6%89%8B%E5%AF%AB/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1615248000,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"term","lang":"zh","lastmod":1615248000,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/data-structures/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/data-structures/","section":"tags","summary":"","tags":null,"title":"Data Structures","type":"tags","url":"/ianlife/tags/data-structures/","weight":0,"wordcount":0},{"authors":null,"categories":["TECH"],"date":1615248000,"description":"在電腦科學中，trie，又稱字首樹或字典樹，是一種有序樹，用於儲存關聯陣列，其中的鍵通常是字串。","dir":"blog/technology/data_structures_and_algorithms/","expirydate":-62135596800,"fuzzywordcount":400,"keywords":["演算法","資料結構","Data Structures","Algorithm","Trie","字首樹","字典樹"],"kind":"page","lang":"zh","lastmod":1615248000,"objectID":"966c45bb0d352be34385b13bbe054e39","permalink":"https://ianjustin39.github.io/ianlife/algorithms/tries/","publishdate":"2021-03-09T00:00:00Z","readingtime":2,"relpermalink":"/ianlife/algorithms/tries/","section":"blog","summary":"","tags":["Algorithm","Data Structures"],"title":"字典樹 - Trie","type":"Data Structures and Algorithms","url":"algorithms/tries","weight":0,"wordcount":355},{"authors":null,"categories":["TECH"],"date":1615075200,"description":"","dir":"blog/technology/data_structures_and_algorithms/","expirydate":-62135596800,"fuzzywordcount":400,"keywords":["演算法","Algorithm","Binary search","資料結構","Data Structures","二分搜尋"],"kind":"page","lang":"zh","lastmod":1615075200,"objectID":"8f9a5ac419e7d8d884844dffeaddfcbf","permalink":"https://ianjustin39.github.io/ianlife/algorithms/binary-search/","publishdate":"2021-03-07T00:00:00Z","readingtime":2,"relpermalink":"/ianlife/algorithms/binary-search/","section":"blog","summary":"\u003cp\u003e\u003ca href=\"https://www.geeksforgeeks.org/binary-search/\" target=\"_blank\"\u003e圖片來源\u003c/a\u003e\n\u003cbr\u003e\u003c/p\u003e","tags":["Algorithm","Data Structures"],"title":"二分搜尋演算法 (Binary search algorithm) - 終極密碼","type":"Data Structures and Algorithms","url":"algorithms/binary-search","weight":0,"wordcount":336},{"authors":null,"categories":null,"date":1613865600,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"term","lang":"zh","lastmod":1613865600,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/categories/learning/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/categories/learning/","section":"categories","summary":"","tags":null,"title":"Learning","type":"categories","url":"/ianlife/categories/learning/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1613865600,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"term","lang":"zh","lastmod":1613865600,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/series/%E5%BE%9E%E7%8F%BE%E5%9C%A8%E9%96%8B%E5%A7%8B%E8%AA%8D%E7%9C%9F%E8%AE%80%E6%9B%B8/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/series/%E5%BE%9E%E7%8F%BE%E5%9C%A8%E9%96%8B%E5%A7%8B%E8%AA%8D%E7%9C%9F%E8%AE%80%E6%9B%B8/","section":"series","summary":"","tags":null,"title":"從現在開始認真讀書","type":"series","url":"/ianlife/series/%E5%BE%9E%E7%8F%BE%E5%9C%A8%E9%96%8B%E5%A7%8B%E8%AA%8D%E7%9C%9F%E8%AE%80%E6%9B%B8/","weight":0,"wordcount":0},{"authors":null,"categories":["Learning"],"date":1613865600,"description":"40歲是『夾心世代』。為了過得更好，留下對自己真正必要的東西。","dir":"blog/learning/reading/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":["為了遇見40歲更好的自己","讀書心得"],"kind":"page","lang":"zh","lastmod":1613865600,"objectID":"c8fb622f43f4734bf58fdf09ad4c80e5","permalink":"https://ianjustin39.github.io/ianlife/read/40-years-old/","publishdate":"2021-02-21T00:00:00Z","readingtime":1,"relpermalink":"/ianlife/read/40-years-old/","section":"blog","summary":"讀後心得 40歲是夾在上一代及下一代中間的一個世代，為了讓自己過得更好，需要學會捨棄一些事物。但往往要捨棄時，又會有些捨不得。就像要整理自己的衣櫃時，拿出很多衣服可能一年內根本沒拿出來穿過，但卻捨不得丟掉，又把他放回衣櫃裡佔去了衣櫃的空間。而哪些東西是該捨棄，而為什麼要捨棄，捨棄之後可以達到什麼效果，這本書基本上都有提到。書中有5個大章節、43個小章節，我挑幾個感受比較深的項目拿來舉例。\n1. 『勇於捨棄』，提升人生的品質 我還年輕，我全身都很健康；這個我以前就是這樣做，絕對沒問題。這些『自信』、『堅持』大家一定都有過。但隨著時間的推移，我們會變老，時代會進步。需要不段的定期檢討、不段的求新求變，才不會被社會淘汰。華特·迪士尼說過：『迪士尼永遠不會完工，維持現狀等於是一種退步。』\n2. 習慣改變，行動自然改變 一開始有提到整理衣櫃。根據調查顯示，女性的衣櫃內有70%的衣服是沒再穿的，只有30%的衣服是平常有再穿的。作者建議把這70%的衣服丟掉，留下真正需要的30%。而依照人的習慣，還是會把這70%補滿。但補滿以後的衣櫃，裡面都是會穿出去的衣服。套用到人身上也一樣，應該適時的檢視並捨棄自己不需要的東西，補充新事物給自己。\n3. 透過『選擇與集中』，提升工作的成果 在樹立目標的時候，我們往往會想要達成多件事情。例如：每個月要讀完一本書、英文要考到多益900分、要養成每天運動的習慣、要學習股票投資\u0026hellip;等等。但之後會發現每件事都有做，但都沒有達到目標。研究顯示，人類大腦無法同時判斷多組情報，因此三種左右是最適當的數量。所以我們可以把要執行的事情縮至三項，將其他事項暫時捨去，才可以專心的去完成每件事。此外，也要定期的檢視自己的執行項目是否有需要或是可更新成更好的方法，並定期的記錄下來。\n4. 調整『時間分配』，改變成長速度 『我今天要看完一個線上課程，但上完班好累喔，休息一下再看好了！』，相信大家都有這個經驗，但休息一下之後，就準備洗澡睡覺了。如何避免這種情況發生呢？書裡建議我們，事先『算好』時間。也就是將你要做的是用時間去切分好，如下圖：\n應先固定好時間，再決定做什麼事。但通常我們無法『完美的』執行我們的計劃，有時可能會有突發狀況發生，所以也必須捨棄『行程必須百分之百完成』的義務感，並不是沒做到就是失敗，而是要有些彈性。\n5. 和『真正重要的人』建立人際關係 到新公司就減少與前公司聚餐的次數，因為『如果不跟現在公司的同事打好關係，就無法創造成果。』。\n並不是到了新公司就要捨棄舊同事，而是現在是與新同事共事，要與他們一起創造成果。但如何與同事來往更加緊密？書中提到『讓溝通戲劇性改變之三種應可棄的東西』\n 為了得到旁人的信賴，請停止『責人』：在遇到問題時，應該先思考自己可以付出什麼，而非先找戰犯。 若想討人喜歡，請捨棄『想討人喜歡的念頭』：應該適時的表達意見，而不是一直考慮是否會被對方討厭。 想要聽見對方的真心話，請捨棄『先入為主的觀念』：產品好不好用，是客戶決定。我們應該思考『這件事由誰判定？』而非自己先覺得對方怎想。   『改變行為一定可以改變結果』，書中讓我們思考什麼該東西是現在應該捨去的。例如：過度的自信、自我堅持、達到目標途中不需要的東西\u0026hellip;等等。專心對待眼前最重要的事物，才有辦法完成目標。這本書雖然有些觀點個人是稍微不認同，不過整體來說是不錯的，可以看看！！\n閱讀筆記 若想參考閱讀筆記，可以點 這裡 參考","tags":["讀書心得"],"title":"為了遇見40歲更好的自己","type":"讀書心得","url":"/read/40-years-old","weight":0,"wordcount":27},{"authors":null,"categories":null,"date":1613865600,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"term","lang":"zh","lastmod":1613865600,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/","section":"tags","summary":"","tags":null,"title":"讀書心得","type":"tags","url":"/ianlife/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/","weight":0,"wordcount":0},{"authors":null,"categories":["Learning"],"date":1611360000,"description":"在華氏 25 度的房間內有著一塊冰塊，隨著房間溫度緩慢的增加，26、27、28 。冰塊依然在，29、30、31 直到 32 （攝氏零度）度時，冰塊開始融化。如同習慣一樣，一開始可能沒有太大的差異，但從某一刻開始就會起到巨大的變化。","dir":"blog/learning/reading/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":["原子習慣","讀書心得","atom habits"],"kind":"page","lang":"zh","lastmod":1611360000,"objectID":"96a2607d767724880dfca58dff1b0dc8","permalink":"https://ianjustin39.github.io/ianlife/read/atom-habits/","publishdate":"2021-01-23T00:00:00Z","readingtime":1,"relpermalink":"/ianlife/read/atom-habits/","section":"blog","summary":"讀後心得 如果每天進步百分之一，持續一年你會進步37倍； 每天退步百分之一，一年後就會弱化到趨近於零，時間會放大成功與失敗之間的差距。 當我們想著要改變的時候，往往想著馬上就可以看到成果，但都忽略一些細微的改變。想想每年年初都訂立一些目標，我 TOEIC 要考 950 以上、我今年要變成巨巨\u0026hellip;等等。但到了年底發現，我今年跟去年好像一樣都沒變，怎麼會這樣？\n決定成功與失敗的，並非目標，而是系統。\n例如：Ａ跟Ｂ都想要有六塊腹肌，但一年後，Ａ成功的練出了腹肌，Ｂ卻跟原本的一樣。差異在哪？\nＡ一周至少上六天健身房，且有做飲食控管並記錄每天的身體數值、飲食及訓練項目。Ｂ一週也上六天健身房，但卻沒有控制飲食以及紀錄。兩個人的目標相同，但執行方式（系統）卻不一樣，所以造就了不同的結果。\n可以發現，雖然定了目標，但系統執行的方向不對，所呈現的結果也不一樣。\n我們往往把注意力過於放在目標上，忽略了如何執行這件事。而對於想要改變習慣，卻因為習慣過於難執行，又或是生活讓我們只能安於現狀，最後只能回歸原樣。\n提示 \u0026lt;\u0026gt; 讓提示顯而易見 渴望 \u0026lt;\u0026gt; 讓習慣有吸引力 回應 \u0026lt;\u0026gt; 讓行動輕而易舉 獎賞 \u0026lt;\u0026gt; 讓獎賞令人滿足 這是書中提到養成習慣的四種方法，簡單用這四個法則來延續六塊肌例子：\n  讓提示顯而易見\n為了養成健身的習慣，將健身手套放在書桌上，看到手套就知道該去健身房了。\n  讓習慣有吸引力\n去健身房只是為了健身？No！當然是為了看健身妹子跟巨巨的肌肉拉，所以會為了這件事所以去健身房。\n  讓行動輕而易舉\n選一間離家走路三分鐘的健身房，這樣就算下雨也只需要撐個傘就可以到了。\n  讓獎賞令人滿足\n每天持續記錄自己的體態，看到改變而帶來的成就感。（或是因為去健身房脫單）\n  而壞習慣就反向而行，這樣就可以比較有效的建立自己的習慣。\n看完這本書後，練習了一下覺得其實滿受用的。書中也有舉許多實例，讓法則比較淺顯易懂。滿值得入手的一本好書，不愧是暢銷前幾名。\n閱讀筆記 因為是心得所以不想打太多筆記類的東西，若想看閱讀筆記，可以點 這裡 參考","tags":["讀書心得","好書推薦"],"title":"原子習慣 - 細微改變帶來巨大成就","type":"讀書心得","url":"/read/atom-habits","weight":0,"wordcount":40},{"authors":null,"categories":null,"date":1611360000,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"term","lang":"zh","lastmod":1611360000,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/%E5%A5%BD%E6%9B%B8%E6%8E%A8%E8%96%A6/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/%E5%A5%BD%E6%9B%B8%E6%8E%A8%E8%96%A6/","section":"tags","summary":"","tags":null,"title":"好書推薦","type":"tags","url":"/ianlife/tags/%E5%A5%BD%E6%9B%B8%E6%8E%A8%E8%96%A6/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1605571200,"description":"","dir":"photograph/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1605571200,"objectID":"fc42ee396fdfdf07c1c83e1212873557","permalink":"https://ianjustin39.github.io/ianlife/photograph/20201117-jiaminglake/","publishdate":"2020-11-17T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/photograph/20201117-jiaminglake/","section":"photograph","summary":"","tags":null,"title":"嘉明湖","type":"photograph","url":"/ianlife/photograph/20201117-jiaminglake/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1601942400,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"term","lang":"zh","lastmod":1601942400,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/behavioural-pattern/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/behavioural-pattern/","section":"tags","summary":"","tags":null,"title":"Behavioural Pattern","type":"tags","url":"/ianlife/tags/behavioural-pattern/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1601942400,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"term","lang":"zh","lastmod":1601942400,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/design-pattern/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/design-pattern/","section":"tags","summary":"","tags":null,"title":"Design Pattern","type":"tags","url":"/ianlife/tags/design-pattern/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1601942400,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"term","lang":"zh","lastmod":1601942400,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/series/%E5%BE%9E%E7%94%9F%E6%B4%BB%E4%B8%AD%E8%AA%8D%E8%AD%98-design-pattern/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/series/%E5%BE%9E%E7%94%9F%E6%B4%BB%E4%B8%AD%E8%AA%8D%E8%AD%98-design-pattern/","section":"series","summary":"","tags":null,"title":"從生活中認識 Design Pattern","type":"series","url":"/ianlife/series/%E5%BE%9E%E7%94%9F%E6%B4%BB%E4%B8%AD%E8%AA%8D%E8%AD%98-design-pattern/","weight":0,"wordcount":0},{"authors":null,"categories":["TECH"],"date":1601942400,"description":"定義一系列演算法，並將其封裝起來，使他們可以相互替換，演算法的變換不影響使用。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":600,"keywords":["Design Pattern","Behavioural Pattern","Strategy Pattern","策略模式"],"kind":"page","lang":"zh","lastmod":1601942400,"objectID":"0f7866f4b9b889b58c79dfd956dbe5c1","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/strategy-pattern/","publishdate":"2020-10-06T00:00:00Z","readingtime":3,"relpermalink":"/ianlife/design-pattern/strategy-pattern/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    定義一系列演算法，並將其封裝起來，使他們可以相互替換，演算法的變換不影響使用。","tags":["Design Pattern","Behavioural Pattern"],"title":"策略模式 | Strategy Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/strategy-pattern","weight":0,"wordcount":505},{"authors":null,"categories":["TECH"],"date":1601856000,"description":"多個物件之間存在著一對多的依賴關係，當一個物件發生改變時，所有跟他有關的物件都會被通知且更新。例如：訂閱youtuber，發布新影片就會接收到通知即觀察者模式。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":500,"keywords":["Design Pattern","Behavioural Pattern","Observer Pattern","觀察者模式"],"kind":"page","lang":"zh","lastmod":1601856000,"objectID":"0fd220d9ec5662798c06ffdf874c9402","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/observer-pattern/","publishdate":"2020-10-05T00:00:00Z","readingtime":3,"relpermalink":"/ianlife/design-pattern/observer-pattern/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    多個物件之間存在著一對多的依賴關係，當一個物件發生改變時，所有跟他有關的物件都會被通知且更新。","tags":["Design Pattern","Behavioural Pattern"],"title":"觀察者模式 | Observer Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/observer-pattern","weight":0,"wordcount":455},{"authors":null,"categories":["TECH"],"date":1601769600,"description":"備忘錄模式在不破壞封裝的前提下，儲存一個物件的某個狀態，以便於需要的時候將物件恢復到原先儲存的狀態。例如：後悔藥。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":500,"keywords":["Design Pattern","Behavioural Pattern","Memento Pattern","備忘錄模式"],"kind":"page","lang":"zh","lastmod":1601769600,"objectID":"835bfcba3865a6c2408d08001c1fc8ff","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/memento-pattern/","publishdate":"2020-10-04T00:00:00Z","readingtime":3,"relpermalink":"/ianlife/design-pattern/memento-pattern/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    在不破壞封裝的前提下，儲存一個物件的某個狀態，以便於需要的時候將物件恢復到原先儲存的狀態。","tags":["Design Pattern","Behavioural Pattern"],"title":"備忘錄模式 | Memento Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/memento-pattern","weight":0,"wordcount":436},{"authors":null,"categories":["TECH"],"date":1601683200,"description":"有狀態的物件，把複雜的邏輯判斷分配到不同的狀態物件中，允許狀態物件在其內部狀態發生改變時改變行為。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":500,"keywords":["Design Pattern","Behavioural Pattern","State Pattern","狀態模式"],"kind":"page","lang":"zh","lastmod":1601683200,"objectID":"42f59d1ae5de1185a240bbd3614e6e3f","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/state-pattern/","publishdate":"2020-10-03T00:00:00Z","readingtime":3,"relpermalink":"/ianlife/design-pattern/state-pattern/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    有狀態的物件，把複雜的邏輯判斷分配到不同的狀態物件中，允許狀態物件在其內部狀態發生改變時改變行為。","tags":["Design Pattern","Behavioural Pattern"],"title":"狀態模式 | State Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/state-pattern","weight":0,"wordcount":490},{"authors":null,"categories":["TECH"],"date":1601596800,"description":"定義一個 Mediator 物件用來封裝一組物件的互動方式。Mediator 藉由避免物件間相互直接的引用，從而降低它們之間的耦合程度，並且可以讓我們獨立地改變這些物件間的互動方式。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":800,"keywords":["Design Pattern","Behavioural Pattern","Mediator Pattern","中介者模式"],"kind":"page","lang":"zh","lastmod":1601596800,"objectID":"b930d4a1aee037cd1fca0862a45364a7","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/mediator-pattern/","publishdate":"2020-10-02T00:00:00Z","readingtime":4,"relpermalink":"/ianlife/design-pattern/mediator-pattern/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    定義一個 Mediator 物件用來封裝一組物件的互動方式。Mediator 藉由避免物件間相互直接的引用，從而降低它們之間的耦合程度，並且可以讓我們獨立地改變這些物件間的互動方式。","tags":["Design Pattern","Behavioural Pattern"],"title":"中介者模式 | Mediator Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/mediator-pattern","weight":0,"wordcount":797},{"authors":null,"categories":["TECH"],"date":1601510400,"description":"迭代氣模式提供一種方法可以順序性讀取一個集合物件中的各個元素，而又不會暴露該物件的內部表示。如 Java 中的 Collection、List、Set、Map 等都包含了迭代器。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":600,"keywords":["Design Pattern","Behavioural Pattern","Iterator Pattern","迭代器模式"],"kind":"page","lang":"zh","lastmod":1601510400,"objectID":"72e9c85a46a3874975291320408e073b","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/iterator-pattern/","publishdate":"2020-10-01T00:00:00Z","readingtime":3,"relpermalink":"/ianlife/design-pattern/iterator-pattern/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    提供一種方法可以順序性讀取一個集合物件中的各個元素，而又不會暴露該物件的內部表示。","tags":["Design Pattern","Behavioural Pattern"],"title":"迭代器模式 | Iterator Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/iterator-pattern","weight":0,"wordcount":556},{"authors":null,"categories":["TECH"],"date":1601424000,"description":"命令模式將一個請求封裝成一個物件，讓你可用不同的請求對客戶進行參數化、對請求排隊或記錄請求日誌，以及支援可取消的操作。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":700,"keywords":["Design Pattern","Behavioural Pattern","Command Pattern","命令模式"],"kind":"page","lang":"zh","lastmod":1601424000,"objectID":"a0561040390f99c62d35649b4b38efc9","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/command-pattern/","publishdate":"2020-09-30T00:00:00Z","readingtime":4,"relpermalink":"/ianlife/design-pattern/command-pattern/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義   The Command Pattern encapsulates a request as an object, thereby letting you parameterize other objects with different requests, queue or log requests, and support undoable operations.","tags":["Design Pattern","Behavioural Pattern"],"title":"命令模式 | Command Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/command-pattern","weight":0,"wordcount":685},{"authors":null,"categories":["TECH"],"date":1601337600,"description":"責任鏈模式就是將多個物件連成一條鏈，沿著這條鏈傳遞至每一個物件並處理請求，當這個物件沒有處理的權限時，能夠將這個請求，傳遞給下一個物件繼續處理。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":600,"keywords":["Design Pattern","Behavioural Pattern","Chain of Responsibility Pattern","責任鏈模式"],"kind":"page","lang":"zh","lastmod":1601337600,"objectID":"0aeb6eb2855104f9855f139a4b397eca","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/chain-of-responsibility/","publishdate":"2020-09-29T00:00:00Z","readingtime":3,"relpermalink":"/ianlife/design-pattern/chain-of-responsibility/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    將多個物件連成一條鏈，沿著這條鏈傳遞至每一個物件並處理請求。","tags":["Design Pattern","Behavioural Pattern"],"title":"責任鏈模式 | Chain of Responsibility Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/chain-of-responsibility","weight":0,"wordcount":556},{"authors":null,"categories":null,"date":1601251200,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"term","lang":"zh","lastmod":1601251200,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/structural-pattern/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/structural-pattern/","section":"tags","summary":"","tags":null,"title":"Structural Pattern","type":"tags","url":"/ianlife/tags/structural-pattern/","weight":0,"wordcount":0},{"authors":null,"categories":["TECH"],"date":1601251200,"description":"代理模式目的爲其他物件提供一種代理以控制對這個物件的訪問。應用可以為遠端代理、虛擬代理、保護代理、智慧代理等等。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":500,"keywords":["Design Pattern","Structural Pattern","Proxy Pattern","代理模式"],"kind":"page","lang":"zh","lastmod":1601251200,"objectID":"8b7975c4f22e370b75f9d68166d2f53b","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/proxy-pattern/","publishdate":"2020-09-28T00:00:00Z","readingtime":2,"relpermalink":"/ianlife/design-pattern/proxy-pattern/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    爲其他物件提供一種代理以控制對這個物件的訪問。","tags":["Design Pattern","Structural Pattern"],"title":"代理模式 | Proxy Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/proxy-pattern","weight":0,"wordcount":405},{"authors":null,"categories":["TECH"],"date":1601164800,"description":"享元模式是運用共享技術有效地支持大量細粒度的物件。他可以避免大量相似類的開銷，在軟體開發中如果需要生成大量細粒度的類別實體來表示數據，如果這些實體除了幾個參數外基本上都是相同的，這時候就可以使用享元模式來大幅度減少需要實體化類的數量。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":800,"keywords":["Design Pattern","Structural Pattern","Flyweight Pattern","享元模式"],"kind":"page","lang":"zh","lastmod":1601164800,"objectID":"960b3df457548f124187f9ce86986a4b","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/flyweight-pattern/","publishdate":"2020-09-27T00:00:00Z","readingtime":4,"relpermalink":"/ianlife/design-pattern/flyweight-pattern/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    運用共享技術有效地支持大量細粒度的物件。","tags":["Design Pattern","Structural Pattern"],"title":"享元模式 | Flyweight Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/flyweight-pattern","weight":0,"wordcount":739},{"authors":null,"categories":["TECH"],"date":1601078400,"description":"外觀模式為子系統中的一組接口提供一個統一的高層接口，使得子系統更容易使用。比方說，當要找銀行貸款時，我們只需要找專員，而專員把我們的資料拿到後，要回銀行各部門跑流程，最後才能核貸給我們。行員就是接口，銀行各部門就是子系統。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":500,"keywords":["Design Pattern","Structural Pattern","Facade Pattern","外觀模式"],"kind":"page","lang":"zh","lastmod":1601078400,"objectID":"55e3a55aa00c3d6e5578a57e9814f9ce","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/facede-pattern/","publishdate":"2020-09-26T00:00:00Z","readingtime":3,"relpermalink":"/ianlife/design-pattern/facede-pattern/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    為子系統中的一組接口提供一個統一的高層接口，使得子系統更容易使用。","tags":["Design Pattern","Structural Pattern"],"title":"外觀模式 | Facade Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/facede-pattern","weight":0,"wordcount":479},{"authors":null,"categories":["TECH"],"date":1600992000,"description":"裝飾者模式可以想成買了一間房子不需要因為要裝潢，而改變整體結構。只需要在既有的結構上，加上要裝潢的材料即可。即動態將責任附加在物件上，若要擴展功能上，裝飾者提供比繼承更有彈性的替代方案。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":500,"keywords":["Design Pattern","Structural Pattern","Decorator Pattern","裝飾者模式"],"kind":"page","lang":"zh","lastmod":1600992000,"objectID":"a77c9a7d38e7cb020faa4850403350c7","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/decorator-pattern/","publishdate":"2020-09-25T00:00:00Z","readingtime":3,"relpermalink":"/ianlife/design-pattern/decorator-pattern/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    裝飾模式動態將責任附加在物件上，若要擴展功能上，裝飾者提供比繼承更有彈性的替代方案。","tags":["Design Pattern","Structural Pattern"],"title":"裝飾者模式 | Decorator Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/decorator-pattern","weight":0,"wordcount":493},{"authors":null,"categories":["TECH"],"date":1600905600,"description":"組合模式就是將元件做分離，依照需求一一組裝起來，建立不同需求的物件。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":900,"keywords":["Design Pattern","Structural Pattern","Composite Pattern","组合模式"],"kind":"page","lang":"zh","lastmod":1600905600,"objectID":"f33943d35f4381a387979b1c3abc43fa","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/composite-pattern/","publishdate":"2020-09-24T00:00:00Z","readingtime":5,"relpermalink":"/ianlife/design-pattern/composite-pattern/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    物件以樹狀結構組合，做為表現出整體-部分的階層關係。","tags":["Design Pattern","Structural Pattern","鐵人賽"],"title":"组合模式 | Composite Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/composite-pattern","weight":0,"wordcount":865},{"authors":null,"categories":null,"date":1600905600,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"term","lang":"zh","lastmod":1600905600,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/","section":"tags","summary":"","tags":null,"title":"鐵人賽","type":"tags","url":"/ianlife/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/","weight":0,"wordcount":0},{"authors":null,"categories":["TECH"],"date":1600819200,"description":"橋接模式是將抽象部分與實現部分分離，使它們都可以獨立的變化。即用合成關係代替繼承關係。如同合成/聚合複用原則。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":400,"keywords":["Design Pattern","Structural Pattern","Bridge Pattern","橋接模式"],"kind":"page","lang":"zh","lastmod":1600819200,"objectID":"23f04ea8783d2b5d61cdb127df184aae","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/bridge-pattern/","publishdate":"2020-09-23T00:00:00Z","readingtime":2,"relpermalink":"/ianlife/design-pattern/bridge-pattern/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    將抽象部分與實現部分分離，使它們都可以獨立的變化。","tags":["Design Pattern","Structural Pattern","鐵人賽"],"title":"橋接模式 | Bridge Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/bridge-pattern","weight":0,"wordcount":399},{"authors":null,"categories":["TECH"],"date":1600732800,"description":"適配器模式如同出國玩時，一定會有使用電器的需求。但每個國家的插座及電壓都不一樣，這時就會拿出事先準備好的轉接頭，藉由轉接頭將插座與電器插頭做連接。適配器模式的目的在於將一個類別的介面轉換成客戶希望的另外一個介面，Adapter使得原本由於介面相容而不能一起工作的那些類別可以一起工作。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":700,"keywords":["Design Pattern","Structural Pattern","Adapter Pattern","適配器模式","接配器模式"],"kind":"page","lang":"zh","lastmod":1600732800,"objectID":"5e8185d6a99d2fdcc754293da146869d","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/adapter-pattern/","publishdate":"2020-09-22T00:00:00Z","readingtime":3,"relpermalink":"/ianlife/design-pattern/adapter-pattern/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    The Adapter Pattern converts the interface of a class into another interface the clients expect.","tags":["Design Pattern","Structural Pattern","鐵人賽"],"title":"適配器模式 | Adapter Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/adapter-pattern","weight":0,"wordcount":628},{"authors":null,"categories":null,"date":1600646400,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"term","lang":"zh","lastmod":1600646400,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/creational-pattern/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/creational-pattern/","section":"tags","summary":"","tags":null,"title":"Creational Pattern","type":"tags","url":"/ianlife/tags/creational-pattern/","weight":0,"wordcount":0},{"authors":null,"categories":["TECH"],"date":1600646400,"description":"建立原型物件，透過複製的方式建立大量物件，而非傳統的建立方式。這為原型模式主張的目標，不但能提升效能，也隱藏了創建新物件的復雜性。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":900,"keywords":["Design Pattern","Creational Pattern","Prototype Pattern","原型模式"],"kind":"page","lang":"zh","lastmod":1600646400,"objectID":"2424a9255953331f9049e13467b007d2","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/prototype-pattern/","publishdate":"2020-09-21T00:00:00Z","readingtime":4,"relpermalink":"/ianlife/design-pattern/prototype-pattern/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    用原型例項指定建立物件的種類，並且通過拷貝這些原型建立新的物件。","tags":["Design Pattern","Creational Pattern","鐵人賽"],"title":"原型模式 | Prototype Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/prototype-pattern","weight":0,"wordcount":807},{"authors":null,"categories":["TECH"],"date":1600560000,"description":"生成器模式就是將元件做分離，依照需求一一組裝起來，建立不同需求的物件。如同不同的人組一台電腦需要各種不同的零件一樣。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":900,"keywords":["Design Pattern","Creational Pattern","Builder Pattern","生成器模式"],"kind":"page","lang":"zh","lastmod":1600560000,"objectID":"4ac5f31498e8ce0fef67005fa7eea270","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/builder-pattern/","publishdate":"2020-09-20T00:00:00Z","readingtime":5,"relpermalink":"/ianlife/design-pattern/builder-pattern/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    把一個複雜物件的建構與樣貌分離，如此相同的建構過程可以產生不同樣貌的物件","tags":["Design Pattern","Creational Pattern","鐵人賽"],"title":"生成器模式 | Builder Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/builder-pattern","weight":0,"wordcount":865},{"authors":null,"categories":["TECH"],"date":1600473600,"description":"抽象工廠主要是由繼承來的次類別來決定要產生哪種實體產品，其主要目的是將客戶從實體型態中鬆綁。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":700,"keywords":["Design Pattern","Creational Pattern","Abstract Factory Method","抽象工廠模式"],"kind":"page","lang":"zh","lastmod":1600473600,"objectID":"4a4ee77777cd4b7f4ff205cbb807e504","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/abstract-factory-pattern/","publishdate":"2020-09-19T00:00:00Z","readingtime":4,"relpermalink":"/ianlife/design-pattern/abstract-factory-pattern/","section":"blog","summary":"","tags":["Design Pattern","Creational Pattern","鐵人賽"],"title":"抽象工廠模式 | Abstract Factory Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/abstract-factory-pattern","weight":0,"wordcount":646},{"authors":null,"categories":["TECH"],"date":1600387200,"description":"簡單工廠模式：藉由定義一個class來負責建立其他class的instance，被建立的instance通常都具有共同的super class；工廠方法模式：定義了一個建立物件的insterface，由子類別決定實體化的類別為何者。而兩者之間的差異在...","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":1000,"keywords":["Design Pattern","Creational Pattern","Factory Method","Sample Factory","工廠模式","工廠方法模式","簡單工廠模式"],"kind":"page","lang":"zh","lastmod":1600387200,"objectID":"7a09007a457514f569ec993efb1abe3c","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/factory-pattern/","publishdate":"2020-09-18T00:00:00Z","readingtime":5,"relpermalink":"/ianlife/design-pattern/factory-pattern/","section":"blog","summary":"","tags":["Design Pattern","Creational Pattern","鐵人賽"],"title":"工廠模式 | Factory Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/factory-pattern","weight":0,"wordcount":935},{"authors":null,"categories":["TECH"],"date":1600300800,"description":"Singleton = one instance ONLY。單例模式希望執行一個且唯一一個Singleton物件且Singleton物件可以全局使用。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":1000,"keywords":["Design Pattern","Creational Pattern","Singleton Pattern","單例模式"],"kind":"page","lang":"zh","lastmod":1600300800,"objectID":"850f31bee8cfb4ef508a6e487ae2d916","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/singleton-pattern/","publishdate":"2020-09-17T00:00:00Z","readingtime":5,"relpermalink":"/ianlife/design-pattern/singleton-pattern/","section":"blog","summary":"","tags":["Design Pattern","Creational Pattern","鐵人賽"],"title":"單例模式 | Singleton Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/singleton-pattern","weight":0,"wordcount":934},{"authors":null,"categories":null,"date":1600214400,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"term","lang":"zh","lastmod":1600214400,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/design-principle/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/design-principle/","section":"tags","summary":"","tags":null,"title":"Design Principle","type":"tags","url":"/ianlife/tags/design-principle/","weight":0,"wordcount":0},{"authors":null,"categories":["TECH"],"date":1600214400,"description":"迪米特法則，又稱最少知識原則。其定義為各單元對其他單元所知應當有限：只瞭解與目前單元最相關之單元。意思就是，只跟你熟的朋友聊天，不要跟陌生人講話。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":900,"keywords":["Design Pattern","Design Principle","Law of Demeter","LoD","Least Knowledge Principle","LKP","迪米特法則","最少知識原則"],"kind":"page","lang":"zh","lastmod":1600214400,"objectID":"e4df6d18cf0a5043f9a51dad36045fc2","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/law-of-demeter/","publishdate":"2020-09-16T00:00:00Z","readingtime":4,"relpermalink":"/ianlife/design-pattern/law-of-demeter/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    各單元對其他單元所知應當有限：只瞭解與目前單元最相關之單元","tags":["Design Pattern","Design Principle","鐵人賽"],"title":"迪米特法則 | Law of Demeter","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/law-of-demeter","weight":0,"wordcount":834},{"authors":null,"categories":["TECH"],"date":1600128000,"description":"合成/聚合複用原則的在於當要重複使用套件時，應該先考慮使用組合/聚合的方式，其次才是繼承。而如果要使用繼承的話，則須符合里氏替換原則(LSP)。在這之前，要先了解什麼是合成？什麼是聚合？他們又與繼承差在哪？","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":700,"keywords":["Design Pattern","Design Principle","合成複用原則","組合/聚合複用原則","CRP","CARP","Composite/Aggregate Reuse Principle","Composite Reuse Principle"],"kind":"page","lang":"zh","lastmod":1600128000,"objectID":"0d74badd154313dd7b0343caba9ee7c4","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/composite-aggregate-reuse-principle/","publishdate":"2020-09-15T00:00:00Z","readingtime":3,"relpermalink":"/ianlife/design-pattern/composite-aggregate-reuse-principle/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    盡量使用組合(contains-a)/聚合(has-a)方式來代替繼承(is-a)來達到重複使用的目的","tags":["Design Pattern","Design Principle","鐵人賽"],"title":"合成/聚合複用原則 | Composite/Aggregate Reuse Principle","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/composite-aggregate-reuse-principle","weight":0,"wordcount":632},{"authors":null,"categories":["TECH"],"date":1600041600,"description":"高層模組不應該依賴低層模組，是兩者都應該依賴抽象；而抽相不應該依賴細節，應該是細節應該依賴於抽象，這是依賴反轉原則的目的。他不但可以減低類別間的耦合，也提高了系統的可讀性及可維護性。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":400,"keywords":["Design Pattern","Design Principle","Dependency Inversion Principle","DIP","依賴反轉原則"],"kind":"page","lang":"zh","lastmod":1600041600,"objectID":"b8201c805a87ef7c2d522bf6e265dafc","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/dependence-inversion-principle/","publishdate":"2020-09-14T00:00:00Z","readingtime":2,"relpermalink":"/ianlife/design-pattern/dependence-inversion-principle/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    依賴反轉原則(DIP)的定義有兩點：","tags":["Design Pattern","Design Principle","鐵人賽"],"title":"依賴反轉原則 | Dependency Inversion Principle","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/dependence-inversion-principle","weight":0,"wordcount":377},{"authors":null,"categories":["TECH"],"date":1599955200,"description":"介面隔離原則目的在於客戶不應該被強迫依賴他們不使用的方法。如同一個公司有一般工程師及資深工程師。資深工程師可能還要囊括一些報告的工作，但一般工程師不用，這時工程師的技能分類就很重要了。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":500,"keywords":["Design Pattern","Design Principle","Interface Segregation Principle","ISP","介面隔離原則"],"kind":"page","lang":"zh","lastmod":1599955200,"objectID":"a374670262b57aeb2538635ac9db5a68","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/interface-segregation-principle/","publishdate":"2020-09-13T00:00:00Z","readingtime":3,"relpermalink":"/ianlife/design-pattern/interface-segregation-principle/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    Clients should not be forced to depend on methods that they do not use.","tags":["Design Pattern","Design Principle","鐵人賽"],"title":"介面隔離原則 | Interface Segregation Principle","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/interface-segregation-principle","weight":0,"wordcount":479},{"authors":null,"categories":["TECH"],"date":1599868800,"description":"里氏替換原則主要在於子類別可以擴充套件父類別的功能，但不改變父類別原有的功能。就像老鷹跟企鵝都是鳥，老鷹會飛但企鵝不會。但企鵝不能去更改鳥類內的方法，只好經由其他設計達成目的。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":1100,"keywords":["Design Pattern","Design Principle","Liskov Substitution Principle","LSP","里氏替換原則"],"kind":"page","lang":"zh","lastmod":1599868800,"objectID":"cdb1958fc822d00749b856bcbea5e801","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/liskov-substitution-principle/","publishdate":"2020-09-12T00:00:00Z","readingtime":5,"relpermalink":"/ianlife/design-pattern/liskov-substitution-principle/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.","tags":["Design Pattern","Design Principle","鐵人賽"],"title":"里氏替換原則 | Liskov Substitution Principle","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/liskov-substitution-principle","weight":0,"wordcount":1061},{"authors":null,"categories":["TECH"],"date":1599782400,"description":"擴充系統時，應該由新增程式碼代替修改程式碼。如同電鑽，可以換各種不同的鑽頭，而電鑽本身並不需要被改造，就符合開閉原則。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":500,"keywords":["Design Pattern","Design Principle","Open/Closed Principle","OCP","開閉原則"],"kind":"page","lang":"zh","lastmod":1599782400,"objectID":"baa34f00ef96fe76d2949e2dbd68c040","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/open-closed-principle/","publishdate":"2020-09-11T00:00:00Z","readingtime":3,"relpermalink":"/ianlife/design-pattern/open-closed-principle/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    Software entities like classes, modules and functions should be open for extension but closed for modifications.","tags":["Design Pattern","Design Principle","鐵人賽"],"title":"開閉原則 | Open/Closed Principle","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/open-closed-principle","weight":0,"wordcount":432},{"authors":null,"categories":["TECH"],"date":1599696000,"description":"一個類別只能有一個改變的原因。你做你該做的事，我做我該做的事。你我互不干擾，這就是單一職責原則。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":500,"keywords":["Design Pattern","Design Principle","Single Responsibility Principle","SRP","單一職責原則"],"kind":"page","lang":"zh","lastmod":1599696000,"objectID":"8f0c2397eff2ae923b68595675a999c8","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/single-responsibility-principle/","publishdate":"2020-09-10T00:00:00Z","readingtime":2,"relpermalink":"/ianlife/design-pattern/single-responsibility-principle/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    There should never be more than one reason for a class to change.","tags":["Design Pattern","Design Principle","鐵人賽"],"title":"單一職責原則 | Single Responsibility Principle","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/single-responsibility-principle","weight":0,"wordcount":405},{"authors":null,"categories":["TECH"],"date":1599609600,"description":"使用Design Pattern要先了解他的原則及分類，才能在實作中找到匹配的Pattern。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":400,"keywords":["Design Pattern","Design Principle","設計模式","五大基本原則","六大基本原則","七大基本原則"],"kind":"page","lang":"zh","lastmod":1599609600,"objectID":"99b3a8eaa1da2877171dbb1b73f36644","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/design-patterns-and-principle/","publishdate":"2020-09-09T00:00:00Z","readingtime":2,"relpermalink":"/ianlife/design-pattern/design-patterns-and-principle/","section":"blog","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://ithelp.ithome.com.tw/articles/10235045\" target=\"_blank\"\u003e本系列文章同步分享於IT邦幫忙第12屆鐵人賽\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cbr\u003e","tags":["Design Pattern","Design Principle","鐵人賽"],"title":"Design Pattern的類型與原則","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/design-patterns-and-principle","weight":0,"wordcount":344},{"authors":null,"categories":["TECH"],"date":1599523200,"description":"Design Pattern是解決問題的一種方案。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":["Design Pattern","設計模式"],"kind":"page","lang":"zh","lastmod":1599523200,"objectID":"3cc58022c1e4561afd97ba91303488fc","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/what_is_design_pattern/","publishdate":"2020-09-08T00:00:00Z","readingtime":2,"relpermalink":"/ianlife/design-pattern/what_is_design_pattern/","section":"blog","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://ithelp.ithome.com.tw/articles/10234830\" target=\"_blank\"\u003e本系列文章同步分享於IT邦幫忙第12屆鐵人賽\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cbr\u003e\n\u003cp\u003e自從當上了工程師後，大多數時間都負責後端的程式開發，從最一開始設計api到現在sdk的經驗中，了解到一個好的程式架構及設計，不只可以讓後續維運成本降低，往後要擴充也會相對容易許多。\u003c/p\u003e","tags":["Design Pattern","鐵人賽"],"title":"什麼是Design Pattern?","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/what_is_design_pattern","weight":0,"wordcount":226},{"authors":null,"categories":null,"date":1588723200,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"term","lang":"zh","lastmod":1588723200,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/bootstrap/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/bootstrap/","section":"tags","summary":"","tags":null,"title":"Bootstrap","type":"tags","url":"/ianlife/tags/bootstrap/","weight":0,"wordcount":0},{"authors":null,"categories":["TECH"],"date":1588723200,"description":"","dir":"blog/technology/build_blog/","expirydate":-62135596800,"fuzzywordcount":400,"keywords":null,"kind":"page","lang":"zh","lastmod":1588723200,"objectID":"50cf604c9e0e3a107bdeaa3c0b071136","permalink":"https://ianjustin39.github.io/ianlife/build-blog/build_photograph_in_hugo/","publishdate":"2020-05-06T00:00:00Z","readingtime":2,"relpermalink":"/ianlife/build-blog/build_photograph_in_hugo/","section":"blog","summary":"\u003cp\u003e剛開始架設網站時就決定要在網站內架一個相簿，這篇會分享如何用Bootstrap+Masonry+magnificPopup建構屬於你自己的相片牆\u003c/p\u003e","tags":["Blog","Hugo","Bootstrap"],"title":"用Bootstrap + Masonry + magnific Popup架設個人相簿","type":"Blog","url":"/build-blog/build_photograph_in_hugo","weight":0,"wordcount":302},{"authors":null,"categories":null,"date":1588377600,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"term","lang":"zh","lastmod":1588377600,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/github/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/github/","section":"tags","summary":"","tags":null,"title":"github","type":"tags","url":"/ianlife/tags/github/","weight":0,"wordcount":0},{"authors":null,"categories":["TECH"],"date":1588377600,"description":"","dir":"blog/technology/build_blog/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1588377600,"objectID":"cf668ef5a54071881d259c576c2ae29a","permalink":"https://ianjustin39.github.io/ianlife/build-blog/deploy_hugo_on_github/","publishdate":"2020-05-02T00:00:00Z","readingtime":2,"relpermalink":"/ianlife/build-blog/deploy_hugo_on_github/","section":"blog","summary":"\u003cp\u003e之前用Hugo架設個人網站，但架設完成後還是需要部署到一個平台，才有辦法瀏覽\u0008，\n這篇就來分享如何將網頁部署到GitHub以及途中遇到的一些問題\u003c/p\u003e","tags":["blog","github","hugo"],"title":"部署Hugo個人網頁至GitHub","type":"Blog","url":"/build-blog/deploy_hugo_on_github","weight":0,"wordcount":256},{"authors":null,"categories":null,"date":1588291200,"description":"","dir":"about/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1588291200,"objectID":"a69934980f795699f7cc4d8a50a604b2","permalink":"https://ianjustin39.github.io/ianlife/about/","publishdate":"2020-05-01T00:00:00Z","readingtime":1,"relpermalink":"/ianlife/about/","section":"about","summary":"我是IAN，一名軟體工程師\nblog紀錄學習心得以防腦容量不足忘記學了什麼，同時也分享自己的人生！！\n 興趣是攝影及旅遊，也喜愛健身，目前正在朝0.5個巨巨的目標邁進\n 有時喜悅與人分享，遠比獨享還來的快樂 ｜ 謦語錄\n 若有任何問題歡迎與我聯繫！！\ngmail: ianjustin39@gmail.com\ngithub: https://github.com/ianjustin39","tags":null,"title":"About Me","type":"about","url":"/ianlife/about/","weight":0,"wordcount":11},{"authors":null,"categories":null,"date":1588291200,"description":"","dir":"photograph/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1588291200,"objectID":"b69c5c5b426ecf644ffdce5394754260","permalink":"https://ianjustin39.github.io/ianlife/photograph/","publishdate":"2020-05-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/photograph/","section":"photograph","summary":"","tags":null,"title":"Photograph","type":"photograph","url":"/ianlife/photograph/","weight":0,"wordcount":0},{"authors":null,"categories":["TECH"],"date":1588204800,"description":"","dir":"blog/technology/build_blog/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1588204800,"objectID":"fcee15e8a189f22cba64f5b002018f55","permalink":"https://ianjustin39.github.io/ianlife/build-blog/get_started_hugo/","publishdate":"2020-04-30T00:00:00Z","readingtime":1,"relpermalink":"/ianlife/build-blog/get_started_hugo/","section":"blog","summary":"\u003cp\u003e一直有想要寫一些文章記錄生活，身為一個工程師，難免會有想要自己架設的靈魂（？，\n最近發現hugo可以快速架站，除了有template以外也可以自己更改裡面的配置\n，對於一個前端小菜鳥來說，算是一大福音ＸＤ，於是開始了這條漫漫長路～\u003c/p\u003e","tags":["hugo","blog"],"title":"使用Hugo建立個人網頁","type":"Blog","url":"/build-blog/get_started_hugo","weight":0,"wordcount":117},{"authors":null,"categories":null,"date":-62135596800,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/en/categories/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/en/categories/","section":"categories","summary":"","tags":null,"title":"Categories","type":"categories","url":"/ianlife/en/categories/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":-62135596800,"description":"","dir":"contact/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":-62135596800,"objectID":"6afdd20c496c23439408a9385435eca0","permalink":"https://ianjustin39.github.io/ianlife/contact/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/contact/","section":"contact","summary":"","tags":null,"title":"Contact","type":"contact","url":"/ianlife/contact/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":-62135596800,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"home","lang":"en","lastmod":-62135596800,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/en/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/en/","section":"","summary":"","tags":null,"title":"Life Story","type":"page","url":"/ianlife/en/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":-62135596800,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/en/series/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/en/series/","section":"series","summary":"","tags":null,"title":"Series","type":"series","url":"/ianlife/en/series/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":-62135596800,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/en/tags/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/en/tags/","section":"tags","summary":"","tags":null,"title":"Tags","type":"tags","url":"/ianlife/en/tags/","weight":0,"wordcount":0}]