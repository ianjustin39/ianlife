Now, let's switch gears a little bit and talk about some code smells that occur when you're making changes to the code. The first of which is called divergent change. The divergent change code smells occur when you have to change a class in many different ways for many different reason. This closely relates to the large class or God class smell. When you have a large class, it will have many different responsibilities. These responsibilities may need to be changed in a variety of ways for a variety of purposes. So, poor separation of concerns is a common cause of divergent change. It will be nice, if your class only had one specific purpose as it should. This would reduce the number of reasons the code would need to be changed. And as a result, reduce the variety of changes that you would need to implement. If you find that you're changing a class in multiple ways, that maybe a good indicator that the responsibilities of the class should be broken up into separate classes and these responsibilities should be extracted into their own classes. The original large class would then delegate the responsibilities to these extracted classes. You've now resolved two code smells. Large class and divergent change with one design principle, separation of concerns.

On the flip side, suppose you want to make one sort of change. You want to implement one small requirement, one sort of change. It would be nice, if that change was in one place. You can't always do this, but it would be nice if it was localized. But say, you wanted to make a change for a requirement and it required you to touch a whole bunch of classes all over your design just to do that thing. Maybe that wasn't so great of a design. This code smell is called shotgun surgery where to make a change, you have to take a shotgun to your code and then deal with all the splatter effect. Violent, I know. We didn't name these smells, we're just presenting them to you. This is a commonly occurring smell. A change in one place requires you to fix many other areas of the code as a result. This could happen when you're trying to add a feature, adjust code, fix bugs or change algorithms. Ideally, you want your changes to be localized. But that's not always possible. A change that only affects one or two classes is way better than a change that affects multiple classes. If you have to make changes all over your code, chances are you're going to miss a change or create issues elsewhere. Having modular code, though is not always an option. There are sometimes changes that require shotgun surgery no matter how well designed your code is. For example, say you need to update the copyright statement or licensing. You're going to have to change every file in your system to change a block of copyright text. You can normally resolve the shotgun surgery smell by moving methods around. If you find that a change requires you to make changes to many methods in many different classes, then that can be an indicator that these methods may be better consolidated into one or two classes. That's not to say though, that you should move methods into one class, so that you only have to make changes in one class. That's the large class code smell again. You should move them if it makes sense to you. The fact that a change in one place leads to changes in other places does show that these methods are related in some way. So, perhaps there's a better way to organize them. However, if it makes more sense to leave them as they are, then you may just have to deal with it the way it is.

The next code smell is we're going to talk about is feature envy. Feature envy occurs when you've got a method that is more interested in the details of a class other than the one that it's in. This sounds like a romantic movie. Long lost lovers who end their relationship years ago are still in love with each other despite being in new relationships. They're more concerned with the other's relationship than they are with their own. You, as the viewer are just screaming at the scene that they should end their respective relationships and just be together. They're just never going to be happy until they're in the same place. Well, the solution is the same for this code smell. If it seems like two methods or classes are always talking to one another and should be together, chances are they probably should. If you have a method in a class that seems to like to talk a lot to another class to do its work, it may belong better within that other class. On a similar note, our next mail discusses the issue of when two classes depend too much on one another through two way communication. This code smell is called inappropriate intimacy. Say, you have two classes that talk really closely to each other. So, a method in one class calls methods of the other and vice versa. Should these classes be so closely coupled? Probably not. Likely, there should be some way to remove this cycle. To remove this cycle, you can factor out methods that both classes use into another class. This might free up some of the close communication. At the very least, you should be able to make it, so that the communication only occurs one way. Now, don't get me wrong. Cycles aren't necessarily a bad thing. You may recognize that the state design pattern has cycles. There are going to be situations where these communication cycles are necessary. However, if there is a way to remove the cycle, that would be a good solution to make your design simpler and easier to understand. We previously talked about the Law of Demeter or the principle of least knowledge. That principle specifies which methods you're allowed to call. It's not just private methods you're not allowed to call. Even for public objects, there are specific rules as to when you are not allowed to call a method. The next code smell, message chains. Potentially violates the law of Demeter. Say, you have an object A which has a method get B and this returns a B object. On this B object, you call a method get C which returns a C object. Finally, on that C object, you call upon it to do something. In this case, it could be that the logged meter forbids you from calling methods upon the B or C objects. Having these long message chains where you are calling, getting an object back, then calling again, getting another object is a sign that you may be violating the logged meter and these are bad message chains. Bad message chains cause rigidity or complexity in your design. It also makes code harder to test independently. In order to find an object in the code to get from A to C in this example, I have to navigate the chain and these objects's dependencies. You don't want to bake in a particular navigation to your objects. Let's say, I want to rework my design and restructure those dependencies. If I do that, I'm going to break this code. That's a sign of a brittle design. That's not always to say that if you see a line of code with a chain of calls, it's a bad thing. Sometimes, it can be fine. These message chains could be returning a limited set of objects that we are allowed to call methods on. If these objects follow the Law of Demeter, then it can be a good thing. It's all circumstantial. Now, let's talk about the smell primitive obsession. This is when you rely on the use of built-in types too much. These built-in types or primitives are things likes ints, longs, floats or strings. Now obviously, these are going to have to be used. However, they should only exist where possible at the lowest levels of your code. Overuse of the primitive types occur when you are not identifying obstructions and defining suitable classes. For example, you can conceivably just define or encode everything in your system's strings and put them in arrays. Your code ends looking like something that was developed in the 60s. Back then, that's when you had to do. Since then, languages have evolved to allow us to define our own types for better obstruction. So, you should be using that. Otherwise, you've an non-OO way of thinking. Here's an example for you. So here in Canada, we have postal codes, these may also be called postcodes, eircodes, PIN codes, or ZIP codes, depending on where you live. Basically, it's a series of letters and numbers included in a postal address for the purpose of sorting mail. In Canada, our postal codes consists of six characters, alternating letter, number, letter, number, letter, number. So they look something like this, T6G 2R3. You could easily store this as a string and deal with it as such throughout your system. However, that's what we want to avoid here. That's because a key obstruction would be buried in the detailed code and not very evident when looking at the design of the system say, in a UML class diagram. There would be no clear separation between a postal code string and other strings in the system. Would parts of your system care whether the postal code was all uppercase or had spaces? If you define a PostalCode class, then you can store the characters properly there. It will be much more obvious that this was a key obstruction to the system. You could also include various methods to validate it or calculate the region. If you find that you were using primitive types often at a high level, then that is a good indicator you are not declaring suitable classes and having a primitive obsession code smell in your system.

The next code smell that we're going to talk about is switch statements. Now you may be thinking, what's wrong with the switch statement? Why do they exist if they're bad design? Well, sometimes there's a need to have big, long if else statements in your code. However, there are times that switch statements could be handled better. For example, if your conditionals are checking on type codes or the types of something, then there is a better way of handling these switch statements. Here in this example, the say method checks on the type of animal and has different cases in the switch statement to have the animal say something appropriate, like woof if a dog. You want to be able to reduce these conditionals down to a design that uses polymorphism.

In this improved design, we can have dog and cat objects that know the appropriate thing to say when their say method is called. Have you ever written any code with the thought we might need this someday? If you have, you've violated our next code smell. Speculative generality. Speculative generality occurs when you make a superclass, interface or code that is not needed at the time, but you think you may use it someday. Maybe you want the ability to make subclasses or provide a different implementation eventually, but you don't actually need it right now. If you're doing this, you are introducing generality that may not actually help the code. You are over-engineering the code. With agile development, you want to be practicing just in time design. You want just enough design to take the requirements for a particular iteration to a working system. So at the beginning of each iteration, you would choose the set of requirements that are going to get developed. That is all you need to design for. You can ignore all other requirements in your backlog, because those may never actually be needed. As you know, software changes frequently. Your client could change their mind at any time and drop requirements from the backlog. Your design needs to stay simple. You don't want to spend time writing code that may never actually get used. When you need to generalize, then you generalize. This change may take longer at the time compared to if you set it up beforehand. However, you'll probably save yourself time over all across the system by not writing code that you don't need. It also keeps your code lean, simple and easier to adapt.

Finally, we're at our last code smell, refused request. This occurs when a subclass inherit something and doesn't need it. Think of this like your great aunt Trudy had suddenly passed away. In her will, she left you with her prize figurine set. She has hundreds of these little porcelain figurines that she had collected throughout her life. As much as you loved your great aunt Trudy, you do not have the need, the want or the space for these figurines. What was intended to be a gift turns into more of a burden. This happens in code too. Say, a superclass declared a common behavior across all its subclasses. If you find your that sub classes are inheriting things that they don't use or need, then is it appropriate that the subclasses of this superclass? Maybe it would make more sense for a stand alone class or maybe these unwanted behaviors should not be defined in the superclass. If only sudden subclasses are able to use them, perhaps it would be better to simply define those behaviors in those sub classes only. So, those are examples of code smells. They are really great indicators of bad code and bad design. I recommend that you review your code frequently for those codes smells to make sure that your cover mains reusable, flexible and maintainable. If you're interested in reading more about these code smells or want to know what you're supposed to do in order to resolve these code smells, you can check out Martin Fowler's book, Refactoring, Improving the Design of Existing Code. Just like you can't write the good novel with one draft, you can't write good code without reviewing and adjusting the code to follow design principles. Apply design patterns and avoid code smells. Refactoring is a very important yet sometimes overlooked way of achieving good design. Now, go deodorized your code.

>> Congratulations, you've completed all the content for this course. Now next step with the remaining capstone assignments, you've already analyzed and critiqued a working software product for code smells. Now, it's time to make the code more flexible and reusable by using design patterns. Now, we followup with an end of course quiz that will test your knowledge from all of the material that we've covered in this course. See you next time.


Sometimes, no matter how well you design your code, their are still going to be changes that need to be made. It's difficult, if not impossible to get it right the first time. That's where refactoring comes in. Refactoring is the process of making changes to your code so that the external behaviors of the code are not change, but the internal structure is improved. This is done by making small, incremental changes to code structure and testing frequently to make sure these changes have not altered the behavior of the code. Ideally, you do not want to do a refactoring overhaul once your code is complete. This could be time-consuming and may cause more issues than you're fixing. You want to be making these refactoring changes when you're adding features. Refactoring the code at this point can make the addition easier to achieve. And saves you from needing a complete overhaul sometime down the line. So what are these changes that you need to be making? Similar to the way we see patterns emerge in design, we also see patterns of bad code emerge. These are referred to as anti-patterns. Many of these anti-patterns are identified in the book, Refactoring by Martin Fowler. Where he refers to them as code smells. As a developer, this is a useful resource to have. Not only does the book describes these empty patterns of bad code, but it also provides refactorings that you can complete in order to transform the code to improve the smell. The purpose of these code smells is to sniff out what is bad in the code. Similar to a drug-sniffing-dog that you might see in an airport. You're going to learn how to sniff out these bad coding practices that are not supposed to be there.

In the previous discussion, we asked you to discuss examples of bad code. I'm sure a lot of the examples that you pointed out, we will cover in these lessons. Probably the most common example that comes up is in regards to comments. Normally, the issue is that code has no comments. This can be an issue for many obvious reasons. Having no comments makes it difficult for someone to understand what the code is doing or should be doing. This could be another developer who's just joining the project or a team member who might need to integrate some code. Or maybe it's even you, and you forgotten how your code works. Having no comment is bad, but also having too many comments has issues of its own. They might get out of sync as the code changes. You might say that comments can be seen as deodorant for bad smelling code. A lot of developers will try to cover up bad design by having a lot of comments that explain what the code does or should do. Chances are, if you have a comment that describes a complicated design, you're covering up a bad design.

You may also see reminder comments that say something along the lines of don't forget to this, or if you make a change to this, make sure you update the code in this other method. These are also indicators of bad code. Using comments to explain a design can sometimes indicate that the programming language isn't appropriate. Perhaps the programming language does not support the design principles you're trying to apply. Or maybe you're not using an appropriate programming language to support your designs. For example, in the early years of Java, the concept of generics did not exist yet. Developers previously would have to have comments to explain what they are doing with the code when casting types. Eventually, generics were built into Java. But until that time, many comments had to be used. This is a common occurrence in many young programming languages. Now that Java's a more mature language, you have no excuses. Now, don't get me wrong. I'm not advocating for no comments in the code. Comments are very useful for documenting the APIs or application programmer interfaces in your system. And also for documenting the rationale why a particular choice of data structure or algorithm was made. They also allow your code to be easily used by others. Like most things in programming, there's a balance you need to find, where you have effective comments in your code.

The next codes smell that we're going to talk about is duplicated code. You may have seen this in your own code especially before you learned about object oriented programming or design patterns. Duplicated code is when you have blocks of code that are similar, but have slight differences. These blocks of code appear in multiple places in your software. Let's say you're working on a social networking website. A user can create textual posts that appear on their new feed, on a friend's wall, or in a group. You first create the ability to post on the news feed. These posts were visible by all the user's friends on their news feeds. Once that feature is complete, you then develop the code for posting on a friend's wall. Since you already have the functionality written for posting, you just copy and paste that code to reuse it for posting on a friend's wall. When you create the functionality to post in a group, you do the same thing. You just copy and paste that code for posting in a group. Now, as the website expands, you also want the ability to post pictures and not just texts. To add this functionality, you now have to update the code in all the three places. What if you had other places in the code where a user could post? What if you missed one of those when you had to update the code to allow the posting of pictures? As you can see, if you would just combine the ability to post in one accessible method all forms of post could use it. And when it came time to make a change, you would have just needed to update it in one location. This doesn't just apply to adding functionalities. You may need to update the algorithm or fix a bug. Having to update it in only one location will make it easier to implement the change and reduce the chance that you're missing a block of code that needs to be updated or changed. We talked about it earlier but the D.R.Y. principle applies here. Don't repeat yourself.

Now let's talk about the code smell of long method. This one is relatively self explanatory. You don't want to have long methods. Having a long method can sometimes indicate that there is more occurring in that method than should be. Or it's more complex than it needs to be. But how long is too long? It really depends. There's no magic rule that says that a method with x amount of lines is too long. For example, methods that set up a user interface tend to be naturally long, despite being focused on one specific task. This obviously depends on the toolkit being used. Generally though, such methods aren't that complicated for their length, so a long method here might be okay. The code smell also could depend on the programming language. Smalltalk methods tend to be short, say about 15 lines on average. Designs in that language tend to have highly cohesive classes and methods, but also highly coupled. Some developers suggest that having an entire method visible at once on a screen is a good guideline, saying no more than 50 lines of code. But they've been studies that programmers can handle methods of a couple hundred lines before they start to introduce bugs. Another matter is whether lines of code is even a decent measure of code complexity when figuring if the method is too long.

Similar to having large methods, having large classes is also an issue. These large classes are commonly referred to as God classes, Blob classes, or Black Hole classes. They just keep getting bigger and bigger. They normally start off as a regular size class. But as more responsibilities are needed, these classes seem like the appropriate place to put the responsibilities. But as one of these classes gets more responsibilities, these responsibilities tend to attract more responsibilities. And for convenience, where else are you going to put them but in this class? As you can see, just like a black hole, the class keeps getting larger and larger, and keeps attracting more and more responsibilities. Eventually, you're going to need extensive comments to document where in the code of the class that certain functionalities exist. And again, comments can be an indicator of poor design, and this is no exception. To avoid this, you need to be explicit about the purpose of a class, and keep the class cohesive, so it does one thing well. If a functionality is not specific to the class's responsibility, you may want to consider placing it somewhere else. Like I said, these large classes tend to grow exponentially, so it's better to catch onto this code smell early. Trying to break these up after the fact can be difficult and time consuming.

On the contrary, having two small of a class is also an issue, these are often data classes. Data classes are classes that contain only data and no real functionality. Generally, these classes would have getter and setter methods, but not much else. An example of a data class would be a 2D point class that simply contains x and y coordinates. Think about what the data contained in these data classes is being used for. Instead of just manipulating it with the getter and setter methods, is there something else they are used for that could be placed in this class? Consider looking at the other classes that are manipulating this data. Would some of their behaviors be better placed in one of the data classes? For example, with our 2D point class, you could have various transformation functions that move the point. If a class contains just data with getter and setter methods, it may not be a good obstraction, or a necessary class. A related issue that we see is data clumps. Data clumps are groups of data appearing together in the instance variables of a class, or parameters to methods. Let's say we have a method that does something with integer variables x, y and zed. This method might look something like this.

If we had many methods that perform various manipulations on such variables. It would make more sense to have an object as the parameter, instead of using these variable as parameters over and over again. In this example, we could use a 3D point object as the parameter, which contains the x, y, and zed values. So, the method would now look something like this.

And we would have a Point3D class.

So now, instead of using the three data values as parameters, they are now stored inside an object. And that object can be used in their place as a parameter. You need to be careful here though. You want to make sure that you're not just creating data classes like we talked about. You want these classes to do more than just store data. So you might decide that the original do something method, or a useful part of it, should belong in the Point3D class.

Like a lot of these code smells, fixing one code smell can sometimes lead to creating new smells elsewhere in the code. So if you are creating data classes in order to fix the data clump smell, you're also going to need to resolve the data classes smell by making sure the classes have effective methods, not just getters and setters.

On a similar note, having long parameter lists is also a code smell. This is one code smell that needs some compromise. Having a method with a long parameter list can be difficult to use, which is bad. However, the common solution to reduce the amount of parameters is often to have global variables. These have issues of their own, and generally should be avoided. Having a long parameter list can make the method difficult to use correctly. By having a long parameter list, you are increasing the chance of something going wrong. Generally, these methods require extensive comments to explain what each of the parameters does and what it should be. And as we've discussed before, comments are usually just deodorant for bad code smells. But what if they aren't commented well? Well, then you may need to look inside the implementation to see how they're used. This breaks encapsulation. So how do you win here? The best solution for long parameter lists is to introduce parameter objects. This is a common occurrence in graphics libraries. Sometimes, there will be tool kits where they will pass in an object which gives the context for a graphics routine. So, instead of setting the details, such as the pen color, line width, pen shape, opacity, etc, as individual parameters. You would just provide this context as a parameter object. So when the program needs to execute some drawing method, say draw a circle. You don't need to pass in all the information about what the stroke should look like as individual parameter values.


https://d3c33hcgiwev3.cloudfront.net/A2WVXPVaEeerIw5IFJ7l8g.processed/full/360p/index.mp4?Expires=1595894400&Signature=Qo9boytGtVLWRViLTaHLykAkH3T5Z~24CjjzM5SJpPZ80DcrKUQBp22sqlY4uSUZD3-CSvwbPo0A-ZD4cEgloG5z1NhBs2Gh531v~HtER5UJU43NhJYLgD4tbXuF1808Uoqmc2G~cajwI3-a2UUW1SONohiHNbeXcxtac9vhhXM_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A

https://d3c33hcgiwev3.cloudfront.net/A2bM7_VaEee21A6Q39E2fg.processed/full/360p/index.mp4?Expires=1595894400&Signature=OUBhMuf6cvel-A2YiU60~cvwkEC7-viCTI18dv3BIgV62gYk1GNndPM6UCMtoBcHEjQJ5lJfSeIHR76oVIHHxjELNB~KDEsGFu69NlIiDcfJGkEDiYraWmSNNeVkxAXCNK5mLlEhkXa3fpcAPCMURUzJNKjvdPZE8IkU21Y1P9o_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A

