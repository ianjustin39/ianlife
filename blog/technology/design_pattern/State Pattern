https://d3c33hcgiwev3.cloudfront.net/c-ri8_TEEee9CQq1Qkxfag.processed/full/360p/index.mp4?Expires=1595894400&Signature=KkPIJyotjQ~1ZMZ6htcTDkABu7TrjfLPg4w9IN~8Qwzk4ebExrqncRVbzswV7jfKaz-0u-em8zpHxBAA-S3kSrKq0l1nNHhzwESzSjtxMbskZpmuVMWYEOyYE1el075Gypzwbbazv3SMEveJvZH9KmjLmiMYiNybK-fGz1yQXq0_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A


Think about what your doing this very second. Your obviously watching this lesson, but what else are you doing? Are you sitting, standing, laying down? Let's say I asked you to do a dance but remain in the same state. If you are sitting down, your dance might involve you waving your arms and shoulders and bobbing your head. If you are standing, you would be able to add some foot work to your dance. If you are laying down, you might throw your hands in the air and wiggle your body. All I had to do was tell you to dance, and you chose a dance that was applicable to your current state. I didn't have to specify what your dance should look like. If I told you to tap dance, which is a dance that requires you to tap your feet on the ground, that would be difficult if you we're on the lying down state. Likely, you would have to change your state in order to complete that action. Since the objects in your code are aware of their current state, you can use this premise in your code. They can choose an appropriate behavior based on their current state. When their current state changes, this behavior can be altered. This is the state pattern. So, when should you use the state pattern? The state pattern is primarily used when you need to change the behavior of an object based upon the state that it's in at run-time.
從 1 分 19 秒 處開始播放視頻，並跟著記錄1:19
Let's look at an example. A vending machine represents state pattern well since it has several states and specific actions based on those states. Let's say I wanted to purchase a chocolate bar from a vending machine. The chocolate bar costs $1. I walk up to the vending machine, insert my dollar and make my selection. The machine then dispenses the chocolate bar. I take the chocolate bar and go on my merry way. This will be the typical case for this scenario, but let's explore some other situations that could happen. What if I walked up to the vending machine, inserted my dollar and then decided I didn't want the chocolate bar anymore? I would press the eject money button and the machine would return my dollar.
從 1 分 56 秒 處開始播放視頻，並跟著記錄1:56
What if the vending machine runs out of chocolate bars? The vending machine needs to be keeping track of it's inventory and notifying the customers when there is no more of a particular product left.
從 2 分 5 秒 處開始播放視頻，並跟著記錄2:05
If I represent this as a UML state diagram, it would look like this.
從 2 分 10 秒 處開始播放視頻，並跟著記錄2:10
From this diagram, you can see that there are three states: idle, has 1$, and out of stock. The vending machine is in one of these states at a time. You can also see that there are three triggers, or events. These triggers would be insert dollar, when the dollar is inserted, eject money, when there is a request to eject money, and dispense, when there is a request to dispense a product. There are two actions that the vending machine can do. These actions are doReturnMoney, or doReleaseProduct. Let's see what this might look like in code. My vending machine class would look like this.
從 2 分 43 秒 處開始播放視頻，並跟著記錄2:43
Take a second and think about the different states that the vending machine could be in.
從 2 分 47 秒 處開始播放視頻，並跟著記錄2:47
Before I approach the vending machine the machine is in an idle state, nothing is happening.
從 2 分 52 秒 處開始播放視頻，並跟著記錄2:52
What happens when I insert my dollar? The state of the vending machine changes. There are events to respond to and actions to perform that are now relevant to the vending machine. These would be responding to an eject money request by returning my money, and responding to a dispense request by releasing a product. A third state the machine could be in, would be if the machine is out of stock. It would no longer be able to dispense a product, so how to respond has changed.
從 3 分 19 秒 處開始播放視頻，並跟著記錄3:19
Let's take a look at one way that we can represent this in Java. First, we'll make some singleton state objects. We define our three states as new State objects. State.Idle would denote the idle state, state.HasOneDollar would denote the machine having one dollar, and state.OutOfStock would denote that this machine is out of stock. Our VendingMachine class would look like this in part, currentState refers to a specific state object, whichever denotes the current state of the vending machine. When the machine is instantiated with a stock count greater than zero, the current state is set to State.Idle. If the stock count is not greater than zero, the current state is set to State.OutOfStock. Now, if we look at what happens when I insert a dollar, you can see that if the current state of the vending machine was State.Idle then the current state changes to State.HasOneDollar. If the currentState of the machine was already State.HasOneDollar, my money is returned and the currentState is set to State.Idle. If the currentState of the machine was already State.OutOfStock, my money is returned and the currentState stays in State.OutOfStock.
從 4 分 24 秒 處開始播放視頻，並跟著記錄4:24
But these state objects seem pretty massive and don't have much responsibility themselves. Let's now look at how you can restructure this properly using the state design pattern. We will define a state interface with a method for each trigger that a state needs to respond to. That is insertDollar, ejectMoney and dispense. And we'll have state classes that implement the state interface. One for each state needed, that is IdleState, HasOneDollarState and OutOfStockState. This is the state interface. State classes must implement the methods in this interface to respond to each trigger.
從 4 分 57 秒 處開始播放視頻，並跟著記錄4:57
Next our IdleState class would look like this. Our IdleState class now implements the State interface. When a dollar is inserted the insertDollar method is called, which then calls a set state method upon the vendingMachine object. This changes the current state of the machine to the HasOneDollarState.
從 5 分 15 秒 處開始播放視頻，並跟著記錄5:15
Similarly, in the HasOneDollarState class, when the eject money method is called, the money is returned and setState is called on the vending machine to change the state to the idle state. Here's what happens if the dispense method is called in the HasOneDollarState class. The product is released. Depending on whether stock remains after releasing the product, the vendingmachine's current state is set to either the idleState or the outOfStockState. The vendingmachine class constructor will instantiate each of the state classes. And the current state will refer to one of these state objects. The vendingmachine class would also have methods to handle the triggers as before, but now delegates handling to the current state object. Notice now, how much cleaner the code is, without having long conditionals in these methods.
從 5 分 59 秒 處開始播放視頻，並跟著記錄5:59
The structure of the state pattern generally looks like this. In our example,the vending machine is the context class. It keeps track of it's current state. When a trigger occurs and a request is asked of a context object, it delegates to a state object to actually handle the request. The state pattern is useful when you need to change the behavior of an object based upon changes to its internal state. You can also use the pattern to simplify methods with long conditionals that depend on the object state.