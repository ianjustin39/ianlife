https://d3c33hcgiwev3.cloudfront.net/c-sxFPTEEee9CQq1Qkxfag.processed/full/360p/index.mp4?Expires=1595894400&Signature=i9ZpQVQA4P1hRHWHJfLsbxWoqIg9dWPlgCsC1U83isGXTt0m5Zqd-Quo~rwm2Z6h4oxynVS62fPFkbxFcFozr0uQDsqTx4wLnA3aRV2UIW-ASqabUHLg6z1ACM0wGZsBC9KFwC3fUwvUdtAgV0WQXOIV21H8xY4OOnf3BlMAlfI_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A


Hi, welcome to the second module. In the first module, you learned about a variety of creational and structural design patterns. In this module, you'll learn about behavioral design patterns, these patterns focus on ways that individual objects collaborate to achieve a common goal. By the end of this module, you'll learn about some of the most useful design patterns you can apply to addressing design issues in your software systems. Enjoy.
從 38 秒 處開始播放視頻，並跟著記錄0:38
When, designing software, it's important to recognize how your different objects work together towards a common goal. Each object you make is a piece of a larger solution. In order for each one to do its work effectively, it needs to have a set purpose. Think of it like each person working at a company. If the people of the company didn't have any predefined roles, there would be no way to make sure that each of their functions was being executed. The company would be less effective and not nearly as organized. This situation is like a behavioral pattern. Behavioral patterns also focus on how independent objects work towards a common goal. There are many ways that objects can have their behaviors defined. In this module, I will explain different behavioral patterns that you can use to design software. To give you a better idea of how behavioral patterns can extend to the real world, let's look at some examples. Have you seen the directions on making soup or mixing a drink from powdered ingredients? They would both have similarly described steps to get a container. Empty the ingredients into the container, add water, stir and prepare. The steps are ordered the same way, with some identical steps and some different in implementation.
從 1 分 41 秒 處開始播放視頻，並跟著記錄1:41
Consider this example. Let's say you're an executive chef for a large chain of restaurants that serve pasta. You want the dishes to be consistent at all the restaurant locations in the chain, so you provide instructions for making each dish. Your two most popular dishes are spaghetti with tomato sauce and meatballs and penne noodles with Alfredo sauce and chicken. Both dishes require that you boil water, cook the pasta, add the sauce, add the protein, and garnish the plate. Some of these steps are implemented differently depending on what dish you're making. Each dish has a different protein, sauce, and garnish. So those would be implemented accordingly. Other steps would be implemented the same for both dishes. Both dishes require water to be boiled. Water can only be boiled a singular way regardless of the type of dish being made. You can model this situation with a pasta dish class with a method that makes the recipe for each subclass, spaghetti with meatballs or penne Alfredo. The method knows the general set of steps to make either dish from boiling water to adding the garnish. Steps that are special to a dish, like the sauce to add, are implemented in its subclass. These are all elements of the template method pattern. Which is the design pattern we will be talking about next. The template method defines an algorithm's steps generally, deferring the implementation of some steps to subclasses. It is a behavioral design pattern and is concerned with the assignment of responsibilities. Now it's your turn to come up with a template method.
從 3 分 4 秒 處開始播放視頻，並跟著記錄3:04
The name of your self-driving vehicle template method could possibly be drive to destination. Both the self-driving car and motorcycle would require such a function for reaching their destination. They would need to go through all the steps together. This steps would involve accelerating, steering, breaking and checking if there are other destination. Calls to all of these methods will be laid out inside the template method. It would be called the same way for both subclasses. Though some of the methods being called would differ. For example, how you stir a car is different from how you stir a motorcycle. The template method is best used when you can generalize between two classes into a new super class. Think of it like another technique to use when you notice you have two separate classes with very similar functionality in order of operations. After you use generalization, you can more effectively reuse objects using inheritance, you can share the functionality between classes and allow for clearer and more self-explanatory code.
從 3 分 59 秒 處開始播放視頻，並跟著記錄3:59
Now, let's take a look at how we might create the UML for the template method pattern. Let's go back to our pasta example. We have the PastaDish superclass with a template method, makeRecipe which calls other methods for the steps of the recipe. Some steps are common across specific dishes like boiling water, so boilWater is a method of PastaDish. However, some steps are special to dish like adding the sauce. So addSauce is an abstract method of PastaDish, it will be up to a subclass of pasta dish to provide the addSauce method body to add the right sauce. SpaghettiMeatballs and PenneAlfredo are subclasses of the PastaDish class. They must provide their own versions of addPasta, addSauce, addProtein, and addGarnish.
從 4 分 42 秒 處開始播放視頻，並跟著記錄4:42
Now, it's time to see some java code on how you'd implement the template method. Let's take a look at the code for the PastaDish superclass, PastaDish needs to be an abstract class. You can't create a generic PastaDish, you wouldn't know what pasta, protein, sauce, and garnish to add. So those methods are abstract. The makeRecipe method is our template method. You will notice that this method is marked as final. In Java, the final keyword means that the method declared cannot be overridden by subclasses. This means that neither specific dish subclass can have its own version of makeRecipe. This ensures consistency in the steps of making the dishes and reduces redundant code.
從 5 分 19 秒 處開始播放視頻，並跟著記錄5:19
From within makeRecipe, the other methods are called. For example, it calls boilWater. boilWater is done the same for any subclass. And so its implementation is consolidated in the superclass. The methods addPasta, addProtein, addSauce, and addGarnish are going to be left up to the subclasses, like SpaghettiMeatballs or PenneAlfredo, to provide them. Before I continue, it's time for you to try writing the superclass of a template method.
從 5 分 46 秒 處開始播放視頻，並跟著記錄5:46
Now that I've gone over the PastaDish superclass and its template method, I will go over the subclasses. Let's take a look at what our SpaghettiMeatballs and PenneAlfredo subclasses look like. Both SpaghettiMeatballs and PenneAlfredo extend the PastaDish class. They each have to implement the abstract methods addPasta, addProtein, addSauce, and addGarnish to provide the suitable ingredients for the dish. The addPasta, addProtein, addSauce and addGarnish methods are called in the make recipe template method found in the PastaDish superclass. The template method is inherited in a subclass and behaves as expected to make a dish with a right ingredients. Now, you can try implementing template method subclasses.
從 6 分 27 秒 處開始播放視頻，並跟著記錄6:27
The template method can be helpful if you have two classes with similar functionality. When you notice two classes with a very similar order of operations, you can choose to use a template method. The template method pattern is a practical application of generalization and inheritance. When writing software, you might notice two separate classes that share similarities like each having a method with a very similar algorithm. Rather than making changes to these algorithms in two places, you can consolidate the algorithms to one place within a template method of a superclass for the two classes. You generalize from two separate methods into one template method within a superclass which will be inherited by the two classes. The differences in the algorithms would be done through calls to abstract methods whose implementations are provided by the subclasses.